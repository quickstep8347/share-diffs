<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>QR Stream Receiver — strict (degree-from-frame)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#111;color:#eee}
  header{padding:12px 16px;background:#222;position:sticky;top:0}
  main{padding:16px}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .card{background:#1b1b1b;border-radius:12px;padding:12px}
  button{background:#4caf50;border:none;color:#fff;border-radius:8px;padding:8px 12px;font-weight:600;cursor:pointer}
  button.secondary{background:#333}
  button[disabled]{opacity:.5;cursor:not-allowed}
  .small{opacity:.85;font-size:.9em}
  video{width:100%;max-width:520px;background:#000;border-radius:12px}
  canvas#overlay{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none}
  code{background:#222;padding:2px 6px;border-radius:6px}
  .kv{display:grid;grid-template-columns:auto 1fr;gap:4px 10px}
</style>

<header><b>QR Stream Receiver</b> — strict (uses degree from frame)</header>
<main>
  <div class="row">
    <!-- Camera -->
    <div class="card" style="flex:1;min-width:320px">
      <div style="position:relative">
        <video id="video" autoplay playsinline></video>
        <canvas id="overlay"></canvas>
      </div>
      <div class="small" id="camInfo" style="white-space:pre-wrap;margin-top:6px">–</div>
      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
        <button id="startBtn">Start</button>
        <button id="stopBtn" class="secondary" disabled>Stop</button>
        <select id="cameraSel"></select>
        <label class="small"><input type="checkbox" id="useCanvas"> Use offscreen canvas</label>
        <label class="small">Downscale <input id="downscale" type="range" min="1" max="4" value="1"></label>
        <label class="small"><input type="checkbox" id="drawBoxes" checked> Draw boxes</label>
      </div>
    </div>

    <!-- Status -->
    <div class="card" style="flex:1;min-width:300px">
      <div><b>Status</b></div>
      <div class="kv small" style="margin-top:6px">
        <div>Session:</div>         <div><code id="sid">–</code></div>
        <div>Symbols:</div>         <div><span id="symCount">0</span> / <span id="need">?</span> (unique)</div>
        <div>K (chunks):</div>      <div><span id="K">?</span>, chunk: <span id="cs">?</span> B</div>
        <div>Total bytes:</div>     <div><span id="tot">?</span></div>
        <div>Recovered:</div>       <div><span id="rec">0</span> / <span id="K2">?</span></div>
      </div>
      <div class="small" style="margin-top:8px">Progress</div>
      <div style="height:12px;background:#333;border-radius:6px;overflow:hidden;margin:4px 0 2px">
        <div id="bar" style="height:100%;width:0;background:#4caf50"></div>
      </div>
      <div style="margin-top:10px">
        <button id="saveBtn" disabled>Save File</button>
      </div>
      <div id="msg" class="small" style="margin-top:10px;white-space:pre-wrap"></div>
    </div>

    <!-- Diagnostics -->
    <div class="card" style="flex:1;min-width:320px">
      <div><b>Diagnostics</b></div>
      <div id="diag" class="small" style="white-space:pre-wrap;margin-top:6px"></div>
      <div id="last" class="small" style="white-space:pre-wrap;margin-top:8px"></div>
      <div id="eqstats" class="small" style="white-space:pre-wrap;margin-top:8px"></div>
    </div>
  </div>
</main>

<script>
/*** Helpers ***/
const u32 = n => (n >>> 0);
function b64uToBytes(s){
  const pad = "=".repeat((4 - (s.length % 4)) % 4);
  const b = atob((s + pad).replace(/-/g,'+').replace(/_/g,'/'));
  const ua = new Uint8Array(b.length);
  for (let i=0;i<b.length;i++) ua[i] = b.charCodeAt(i);
  return ua;
}

/*** Tiny PRNG (match Python) ***/
class XorShift32 {
  constructor(seed){ this.state = (seed>>>0) || 0xDEADBEEF }
  rand32(){
    let x = this.state>>>0;
    x ^= (x << 13) >>> 0; x ^= (x >>> 17) >>> 0; x ^= (x << 5) >>> 0;
    this.state = x>>>0; return this.state>>>0;
  }
  randint(a,b){ return a + (this.rand32() % (b - a + 1)) }
}

/*** Session + Decoder ***/
let sess = {
  sid:null, len:0, K:0, cs:0, fec_seed:0,
  seen:new Set(), eqs:[], solved:new Map(), solvedCount:0,
  deg1Total:0
};

function resetSession(meta){
  sess.sid = meta.sid;
  sess.len = meta.len|0;
  sess.K   = meta.K|0;
  sess.cs  = meta.cs|0;
  sess.fec_seed = u32(meta.r);     // unsigned seed
  sess.seen.clear(); sess.eqs.length=0; sess.solved.clear(); sess.solvedCount=0; sess.deg1Total=0;
  reasons = { sid:0, K:0, cs:0, r:0, dup:0, parse:0, nod:0, other:0 };
  updateUI(); updateEqStats();
}

function chosenIndices(symId, d){
  // REQUIRE d to be present
  const rng = new XorShift32(u32(sess.fec_seed ^ symId ^ (sess.K<<16)));
  const D = Math.max(1, Math.min(sess.K, d|0));
  const chosen = new Set();
  while (chosen.size < D) chosen.add(rng.randint(0, sess.K-1));
  return { idxs: Array.from(chosen).sort((a,b)=>a-b), d:D };
}

function ingestSymbol(symId, payload, degree){
  const sel = chosenIndices(symId, degree);
  const idxs = sel.idxs;
  if (idxs.length===1) sess.deg1Total++;
  const data = payload.slice();
  for (const k of Array.from(sess.solved.keys()).sort((a,b)=>a-b)){
    const pos = idxs.indexOf(k);
    if (pos>=0){
      const ck = sess.solved.get(k);
      for (let i=0;i<data.length;i++) data[i]^=ck[i];
      idxs.splice(pos,1);
    }
  }
  if (idxs.length===0) return;
  sess.eqs.push({idxs:new Set(idxs), data});
  peel();
}

function peel(){
  let progress=true;
  while(progress){
    progress=false;
    for (const e of sess.eqs){
      if (e.idxs.size===1){
        const k = e.idxs.values().next().value;
        if (!sess.solved.has(k)){
          sess.solved.set(k, e.data);
          sess.solvedCount++;
          for (const f of sess.eqs){
            if (f===e) continue;
            if (f.idxs.has(k)){
              const ck = e.data, fd=f.data;
              for (let i=0;i<fd.length;i++) fd[i]^=ck[i];
              f.idxs.delete(k);
            }
          }
          progress=true;
        }
      }
    }
    sess.eqs = sess.eqs.filter(e=>e.idxs.size>0);
  }
  updateUI(); updateEqStats();
  if (sess.solvedCount >= sess.K) assembleAndEnableSave();
}

function assembleAndEnableSave(){
  const out = new Uint8Array(sess.K * sess.cs);
  for (let k=0;k<sess.K;k++){
    const c = sess.solved.get(k) || new Uint8Array(sess.cs);
    out.set(c, k*sess.cs);
  }
  const finalBytes = out.slice(0, sess.len);
  const url = URL.createObjectURL(new Blob([finalBytes],{type:"application/octet-stream"}));
  const saveBtn = document.getElementById('saveBtn');
  saveBtn.onclick = ()=>{ const a=document.createElement('a'); a.href=url; a.download=`qrstream_${sess.sid}.bin`; a.click(); };
  saveBtn.disabled = false;
  msg(`✅ Reconstructed ${finalBytes.length} bytes. Save is enabled.`);
}

/*** UI ***/
function msg(s){ document.getElementById('msg').textContent = s; }
function updateUI(){
  document.getElementById('sid').textContent = sess.sid || '–';
  document.getElementById('K').textContent = sess.K || '?';
  document.getElementById('K2').textContent = sess.K || '?';
  document.getElementById('cs').textContent = sess.cs || '?';
  document.getElementById('tot').textContent = sess.len || '?';
  document.getElementById('rec').textContent = sess.solvedCount || 0;
  document.getElementById('symCount').textContent = sess.seen.size;
  const need = sess.K ? Math.ceil(sess.K * 1.10) : 0;
  document.getElementById('need').textContent = need || '?';
  const pct = sess.K ? Math.min(100, Math.floor((sess.solvedCount/sess.K)*100)) : 0;
  document.getElementById('bar').style.width = pct + '%';
}
function minEqDegree(){ let m=Infinity; for (const e of sess.eqs) m=Math.min(m,e.idxs.size); return m===Infinity?0:m; }
function updateEqStats(){
  document.getElementById('eqstats').textContent =
`Equations: ${sess.eqs.length}, min degree in system: ${minEqDegree()}
Total deg=1 seen (raw): ${sess.deg1Total}`;
}

/*** Camera + detector with diagnostics ***/
const vEl = document.getElementById('video');
const overlay = document.getElementById('overlay'); const octx = overlay.getContext('2d', {willReadFrequently:true});
const cameraSel=document.getElementById('cameraSel'), useCanvas=document.getElementById('useCanvas');
const downscale=document.getElementById('downscale'), drawBoxes=document.getElementById('drawBoxes');

let running=false, detector=null, stream=null, rafId=null, deviceId=null;
const off = document.createElement('canvas'); const offCtx=off.getContext('2d',{willReadFrequently:true});
let detPerSec=0, accPerSec=0, lastLen=0, hadPrefix=false, lastErr="";
let reasons = { sid:0, K:0, cs:0, r:0, dup:0, parse:0, nod:0, other:0 };

function sizeOverlayToVideo(){ const r=vEl.getBoundingClientRect(); overlay.width=r.width; overlay.height=r.height; }
function drawDetectionBoxes(codes){
  if (!drawBoxes.checked){ octx.clearRect(0,0,overlay.width,overlay.height); return; }
  sizeOverlayToVideo(); octx.clearRect(0,0,overlay.width,overlay.height);
  octx.lineWidth=2; octx.strokeStyle='#00e676';
  const rw=vEl.videoWidth||1, rh=vEl.videoHeight||1;
  for (const c of codes){
    const pts=c.cornerPoints||[]; if (!pts.length) continue;
    octx.beginPath();
    for (let i=0;i<pts.length;i++){
      const x=(pts[i].x/rw)*overlay.width, y=(pts[i].y/rh)*overlay.height;
      if (i===0) octx.moveTo(x,y); else octx.lineTo(x,y);
    } octx.closePath(); octx.stroke();
  }
}

async function listCameras(){
  const devs=await navigator.mediaDevices.enumerateDevices();
  cameraSel.innerHTML=""; for (const d of devs) if (d.kind==='videoinput'){
    const opt=document.createElement('option'); opt.value=d.deviceId; opt.textContent=d.label||`Camera ${cameraSel.length+1}`; cameraSel.appendChild(opt);
  }
  if (!deviceId && cameraSel.options.length){
    const envIdx=Array.from(cameraSel.options).findIndex(o=>/back|rear|environment/i.test(o.textContent));
    cameraSel.selectedIndex=envIdx>=0?envIdx:0; deviceId=cameraSel.value;
  }
}
cameraSel.onchange=()=>{ deviceId=cameraSel.value; if (running){ stop(); start(); } };

setInterval(()=>{
  const track = stream ? stream.getVideoTracks()[0] : null;
  const st = track ? track.getSettings() : {};
  document.getElementById('camInfo').textContent =
`Detections/s: ${detPerSec}   Accepted/s: ${accPerSec}
Last raw length: ${lastLen}   QS1 prefix: ${hadPrefix}
Video: ${vEl.videoWidth||0}x${vEl.videoHeight||0}  fps(set): ${st.frameRate||'?'}
Reasons (per s): ${JSON.stringify(reasons)}  Last error: ${lastErr || '—'}`;
  detPerSec=0; accPerSec=0; reasons={ sid:0, K:0, cs:0, r:0, dup:0, parse:0, nod:0, other:0 };
}, 1000);

function showBasics(){
  const hasBD=('BarcodeDetector' in window), hasGUM=!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia), secure=window.isSecureContext;
  document.getElementById('diag').textContent =
`BarcodeDetector: ${hasBD}
getUserMedia: ${hasGUM}
isSecureContext: ${secure} (protocol=${location.protocol})
origin: ${location.origin || location.href}`;
}
showBasics();

document.getElementById('startBtn').onclick = start;
document.getElementById('stopBtn').onclick  = stop;

async function start(){
  if (!('BarcodeDetector' in window)){ msg("❌ No BarcodeDetector. Use Chrome/Edge or desktop."); return; }
  detector = new BarcodeDetector({formats:['qr_code']});
  await listCameras();
  try{
    const constraints = { video: deviceId ? {deviceId:{exact:deviceId}} : {facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:720}}, audio:false };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    vEl.srcObject = stream; await vEl.play();
  }catch(e){ msg('getUserMedia error: ' + (e && e.name ? e.name : e)); return; }
  running=true; document.getElementById('startBtn').disabled=true; document.getElementById('stopBtn').disabled=false;
  requestAnimationFrame(loop);
}

function stop(){
  running=false; if (rafId) cancelAnimationFrame(rafId);
  if (stream){ for (const t of stream.getTracks()) t.stop(); stream=null; }
  document.getElementById('startBtn').disabled=false; document.getElementById('stopBtn').disabled=true;
  octx.clearRect(0,0,overlay.width,overlay.height);
}

function updateLastFrameDiag(frame, accepted, why){
  const rHex = frame && (u32(frame.r)).toString(16).padStart(8,'0');
  const sHex = sess.fec_seed ? (sess.fec_seed).toString(16).padStart(8,'0') : '--------';
  const dShow = frame && frame.d;
  document.getElementById('last').textContent =
`Last frame:
  sid match: ${frame && (frame.sid===sess.sid)}
  K   match: ${frame && (frame.K===sess.K)}
  cs  match: ${frame && (frame.cs===sess.cs)}
  r   match: ${frame && (u32(frame.r)===sess.fec_seed)}   (frame.r=0x${rHex}, sess.fec_seed=0x${sHex})
  d (degree): ${dShow}
  symId: ${frame ? frame.i : '–'}   accepted: ${accepted}   reason: ${why||'-'}`;
}

async function loop(){
  if (!running) return;
  let codes=[]; sizeOverlayToVideo();
  try{
    codes = await detector.detect(vEl);
    if (!codes.length && useCanvas.checked){
      const ds=Math.max(1,Number(downscale.value));
      const w=vEl.videoWidth||640, h=vEl.videoHeight||480;
      off.width=Math.floor(w/ds); off.height=Math.floor(h/ds);
      offCtx.imageSmoothingEnabled=false; offCtx.drawImage(vEl,0,0,off.width,off.height);
      codes = await detector.detect(off);
    }
  }catch(e){ lastErr = e.message || String(e); }

  if (codes && codes.length){
    detPerSec += codes.length; drawDetectionBoxes(codes);
    for (const code of codes){
      const raw = code.rawValue || '';
      lastLen = raw.length; hadPrefix = raw.startsWith('QS1|');
      if (!hadPrefix) continue;
      let frame=null;
      try{ frame = JSON.parse(raw.slice(4)); }
      catch(_){ reasons.parse++; updateLastFrameDiag(null,false,'parse'); continue; }

      if (!sess.sid || sess.sid !== frame.sid) resetSession(frame);

      const okSid = frame.sid===sess.sid;
      const okK   = frame.K===sess.K;
      const okCs  = frame.cs===sess.cs;
      const okR   = u32(frame.r)===sess.fec_seed;
      const okD   = (typeof frame.d==='number') && frame.d>=1 && frame.d<=sess.K;

      if (!(okSid && okK && okCs && okR && okD)){
        if (!okSid) reasons.sid++; else if (!okK) reasons.K++; else if (!okCs) reasons.cs++; else if (!okR) reasons.r++; else if (!okD) reasons.nod++; else reasons.other++;
        updateLastFrameDiag(frame,false, !okSid?'sid':!okK?'K':!okCs?'cs':!okR?'r':'d');
        continue;
      }

      if (sess.seen.has(frame.i)){ reasons.dup++; updateLastFrameDiag(frame,false,'dup'); continue; }

      // Accept
      sess.seen.add(frame.i); accPerSec++;
      const payload = b64uToBytes(frame.p);
      ingestSymbol(frame.i, payload, frame.d);
      updateUI(); updateLastFrameDiag(frame,true,'ok');
    }
  } else {
    drawDetectionBoxes([]);
  }
  rafId = requestAnimationFrame(loop);
}
</script>
</html>
