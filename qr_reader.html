<!doctype html>
<html lang="en">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>QR Stream Receiver (LT fountain)</title>
<style>
  body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:0;background:#111;color:#eee}
  header{padding:12px 16px;background:#222;position:sticky;top:0}
  main{padding:16px}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  video{width:100%;max-width:480px;background:#000;border-radius:12px}
  .card{background:#1b1b1b;border-radius:12px;padding:12px}
  .progress{height:12px;background:#333;border-radius:6px;overflow:hidden}
  .bar{height:100%;width:0;background:#4caf50}
  code{background:#222;padding:2px 6px;border-radius:6px}
  button{background:#4caf50;border:none;color:#fff;border-radius:8px;padding:10px 14px;font-weight:600;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  label{display:block;margin:6px 0 4px}
  .small{opacity:.8;font-size:.9em}
</style>
<header>
  <strong>QR Stream Receiver</strong> — LT fountain, arbitrary start, loss tolerant
</header>
<main>
  <div class="row">
    <div class="card" style="flex:1;min-width:300px">
      <label>Camera</label>
      <video id="video" autoplay playsinline></video>
      <div class="small" id="camInfo"></div>
      <div style="margin-top:8px">
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
      </div>
    </div>
    <div class="card" style="flex:1;min-width:280px">
      <div><b>Status</b></div>
      <div class="small">Session: <code id="sid">–</code></div>
      <div class="small">Symbols: <span id="symCount">0</span> / <span id="need">?</span> (unique)</div>
      <div class="progress" style="margin:8px 0 10px">
        <div class="bar" id="bar"></div>
      </div>
      <div class="small">K (chunks): <span id="K">?</span>, chunk: <span id="cs">?</span> B</div>
      <div class="small">Total bytes: <span id="tot">?</span></div>
      <div class="small">Recovered: <span id="rec">0</span> / <span id="K2">?</span></div>
      <div style="margin-top:10px">
        <button id="saveBtn" disabled>Save File</button>
      </div>
      <div id="msg" class="small" style="margin-top:10px;white-space:pre-wrap"></div>
    </div>
  </div>
</main>

<script>
/* ---------- small base64url helpers ---------- */
function b64uToBytes(s){
  const pad = "=".repeat((4 - (s.length % 4)) % 4);
  const b = atob((s + pad).replace(/-/g, '+').replace(/_/g, '/'));
  const ua = new Uint8Array(b.length);
  for (let i=0;i<b.length;i++) ua[i] = b.charCodeAt(i);
  return ua;
}
/* ---------- tiny XorShift32 to mirror Python ---------- */
class XorShift32 {
  constructor(seed){ this.state = seed>>>0 || 0xDEADBEEF }
  rand32(){
    let x = this.state>>>0;
    x ^= (x << 13) >>> 0;
    x ^= (x >>> 17) >>> 0;
    x ^= (x << 5) >>> 0;
    this.state = x>>>0;
    return this.state>>>0;
  }
  randint(a,b){ return a + (this.rand32() % (b - a + 1)) }
}
/* ---------- robust soliton CDF (same math as Python) ---------- */
function robustSolitonCDF(K, c=0.1, delta=0.5){
  let R = Math.max(1, Math.floor(c*Math.log(K/delta)*Math.sqrt(K)));
  const tau = new Array(K+1).fill(0);
  for (let d=1; d<K; d++){
    if (1 <= d && d < Math.floor(K/R)) tau[d] = R/(d*K);
    else if (d === Math.floor(K/R)) tau[d] = R*Math.log(R/delta)/K;
  }
  const rho = new Array(K+1).fill(0);
  rho[1] = 1.0/K;
  for (let d=2; d<=K; d++) rho[d] = 1.0/(d*(d-1));
  let Z = 0;
  for (let d=1; d<=K; d++) Z += rho[d] + tau[d];
  const pmf = new Array(K+1).fill(0);
  for (let d=1; d<=K; d++) pmf[d] = (rho[d] + tau[d]) / Z;
  const cdf = [0.0];
  let s = 0;
  for (let d=1; d<=K; d++){ s += pmf[d]; cdf.push(s); }
  cdf[cdf.length-1] = 1.0;
  return cdf;
}
function sampleDegree(cdf, rng){
  const u = (rng.rand32()>>>0) / 0x100000000;
  let lo = 1, hi = cdf.length-1;
  while (lo < hi){
    const mid = (lo+hi)>>1;
    if (cdf[mid] >= u) hi = mid; else lo = mid+1;
  }
  return lo;
}
/* ---------- Decoder state ---------- */
let sess = {
  sid:null, len:0, K:0, cs:0, fec_seed:0,
  cdf:null,
  // collected symbols: payload bytes (Uint8Array) de-duplicated by symbol id
  seen:new Set(),
  symbols:[],        // {i,payload}
  // LT decoding structures
  eqs:[],            // each equation: {idxs: Set<int>, data: Uint8Array}
  solved:new Map(),  // chunkIndex -> Uint8Array
  solvedCount:0
};
function resetSession(meta){
  sess.sid = meta.sid;
  sess.len = meta.len|0;
  sess.K = meta.K|0;
  sess.cs = meta.cs|0;
  sess.fec_seed = meta.r|0;
  sess.cdf = robustSolitonCDF(sess.K);
  sess.seen.clear(); sess.symbols.length = 0;
  sess.eqs = []; sess.solved.clear(); sess.solvedCount = 0;
  updateUI();
}
/* Recreate the same subset indices used by the encoder (given symbol id) */
function chosenIndices(symId){
  const rng = new XorShift32((sess.fec_seed ^ symId ^ (sess.K<<16)) >>> 0);
  const d = Math.max(1, Math.min(sess.K, sampleDegree(sess.cdf, rng)));
  const chosen = new Set();
  while (chosen.size < d) chosen.add(rng.randint(0, sess.K-1));
  return Array.from(chosen).sort((a,b)=>a-b);
}
/* Insert new symbol -> equation, then run peeling decoder */
function ingestSymbol(symId, payload){
  // Build equation: XOR of unknown source chunks at indices 'idxs' equals 'payload'
  const idxs = chosenIndices(symId);
  // reduce using already solved chunks
  const data = payload.slice(); // copy
  for (const k of Array.from(sess.solved.keys()).sort((a,b)=>a-b)){
    if (idxs.includes(k)){
      const ck = sess.solved.get(k);
      for (let i=0;i<data.length;i++) data[i]^=ck[i];
      // remove k from idxs
      const p = idxs.indexOf(k);
      if (p>=0) idxs.splice(p,1);
    }
  }
  if (idxs.length===0){
    // equation is 0 = data; should be zero; ignore minor inconsistencies
    return;
  }
  sess.eqs.push({idxs:new Set(idxs), data});
  peel();
}
function peel(){
  let progress=true;
  while(progress){
    progress=false;
    // find degree-1 equations
    for (let e of sess.eqs){
      if (e.idxs.size===1){
        const k = e.idxs.values().next().value;
        if (!sess.solved.has(k)){
          // we found chunk k
          sess.solved.set(k, e.data);
          sess.solvedCount++;
          // substitute k into all other equations
          for (let f of sess.eqs){
            if (f===e) continue;
            if (f.idxs.has(k)){
              const ck = e.data;
              const fd = f.data;
              for (let i=0;i<fd.length;i++) fd[i]^=ck[i];
              f.idxs.delete(k);
            }
          }
          progress=true;
        }
      }
    }
    // drop fully reduced equations
    sess.eqs = sess.eqs.filter(e=>e.idxs.size>0);
  }
  updateUI();
  // Check completion
  if (sess.solvedCount >= sess.K){
    assembleAndEnableSave();
  }
}
function assembleAndEnableSave(){
  // order chunks 0..K-1 (zero-padded to cs), then trim to total len
  const out = new Uint8Array(sess.K * sess.cs);
  for (let k=0;k<sess.K;k++){
    const c = sess.solved.get(k) || new Uint8Array(sess.cs);
    out.set(c, k*sess.cs);
  }
  const finalBytes = out.slice(0, sess.len);
  const blob = new Blob([finalBytes], {type:"application/octet-stream"});
  const url = URL.createObjectURL(blob);
  const saveBtn = document.getElementById('saveBtn');
  saveBtn.onclick = ()=>{
    const a = document.createElement('a');
    a.href = url;
    a.download = `qrstream_${sess.sid}.bin`;
    a.click();
  };
  saveBtn.disabled = false;
  msg(`✅ Reconstructed ${finalBytes.length} bytes. You can save the file now.`);
}
/* ---------- UI + Camera ---------- */
function msg(s){ document.getElementById('msg').textContent = s; }
function updateUI(){
  document.getElementById('sid').textContent = sess.sid || '–';
  document.getElementById('K').textContent = sess.K || '?';
  document.getElementById('K2').textContent = sess.K || '?';
  document.getElementById('cs').textContent = sess.cs || '?';
  document.getElementById('tot').textContent = sess.len || '?';
  document.getElementById('rec').textContent = sess.solvedCount || 0;
  const need = Math.ceil(sess.K * 1.1); // expectation; purely for UI
  document.getElementById('need').textContent = need;
  document.getElementById('symCount').textContent = sess.seen.size;
  const pct = Math.min(100, Math.floor((sess.solvedCount / (sess.K||1)) * 100));
  document.getElementById('bar').style.width = pct + '%';
}
let running = false, videoStream = null, detector = null, rafId = null;
async function start(){
  if (!('BarcodeDetector' in window)){
    msg("❌ This browser doesn't support BarcodeDetector API.\nTry Chrome/Edge on Android or load a desktop browser that supports it.\nFallback tips are below in the file.");
    return;
  }
  try{
    detector = new BarcodeDetector({formats:['qr_code']});
  }catch(e){
    msg("❌ BarcodeDetector not available: " + e);
    return;
  }
  videoStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment', width:{ideal:1280}, height:{ideal:720}}, audio:false});
  const v = document.getElementById('video');
  v.srcObject = videoStream;
  await v.play();
  running = true;
  document.getElementById('startBtn').disabled = true;
  document.getElementById('stopBtn').disabled = false;
  document.getElementById('camInfo').textContent = 'Camera running…';
  loop();
}
function stop(){
  running = false;
  if (rafId) cancelAnimationFrame(rafId);
  if (videoStream){
    for (const t of videoStream.getTracks()) t.stop();
    videoStream = null;
  }
  document.getElementById('startBtn').disabled = false;
  document.getElementById('stopBtn').disabled = true;
  document.getElementById('camInfo').textContent = 'Camera stopped.';
}
async function loop(){
  if (!running) return;
  const v = document.getElementById('video');
  try{
    const codes = await detector.detect(v);
    for (const code of codes){
      const raw = code.rawValue || '';
      if (typeof raw === 'string' && raw.startsWith('QS1|')){
        try{
          const frame = JSON.parse(raw.slice(4));
          // new session?
          if (!sess.sid || sess.sid !== frame.sid){
            resetSession(frame);
            msg('New session detected.');
          }
          // sanity check
          if (frame.sid===sess.sid && frame.K===sess.K && frame.cs===sess.cs && frame.r===sess.fec_seed){
            if (!sess.seen.has(frame.i)){
              sess.seen.add(frame.i);
              const payload = b64uToBytes(frame.p);
              ingestSymbol(frame.i, payload);
              updateUI();
            }
          }
        }catch(e){}
      }
    }
  }catch(e){
    // ignore transient errors
  }
  rafId = requestAnimationFrame(loop);
}
document.getElementById('startBtn').onclick = start;
document.getElementById('stopBtn').onclick = stop;
</script>

<!--
Fallbacks if your phone doesn't support BarcodeDetector:
- Use a recent Chrome/Edge on Android (usually works).
- Or run this page on a laptop with a webcam (Chrome/Edge) and scan from there.
- If you must use iOS Safari today, install a QR-to-clipboard app and
  build a tiny “bridge” page that accepts pasted frames — ping me and I’ll add it.
-->
</html>
